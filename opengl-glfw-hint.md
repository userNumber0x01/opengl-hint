# GLFW

> %%отображение ctrl+shift+v%%

## Инициализация, создание, управление окнами

- `glfw.init()` - проверка на поддержку GLFW и подготовка переменных среды.
- `glfw.create_window(width, height, title, monitor, share)` - создание окна.
  - **width** - ширина.
  - **height** - высота.
  - **title** - заголовок.
  - **monitor** (glfw.Monitor) - указатель на объект монитора (создание полноэкранного окна), `None` - оконный режим.
  - **share** (glfw.Window) - указатель на другое окно, с которым вы хотите разделить контекст OpenGL. `None` - новый контекст.
- `glfw.make_context_current(window)` - установка указанного окна в качестве текущего контекста OpenGL.
- `glfw.terminate()` - высвобождение всех ресурсов, завершение работы.
- `glfw.window_should_close(window)` - (true, false) Проверяет, было ли запрошено закрытие окна.
- `glfw.set_window_should_close(window, value)` - `value`=(true, false) Устанавливает флаг, указывающий, должно ли окно закрываться.
- `glfw.swap_buffers(window)` - содержимое заднего буфера (где вы рисуете) становится видимым на экране, а передний буфер (который отображается) становится задним буфером для следующей отрисовки.

## Обработка событий

- `glfw.poll_events()` - (не блокирует программу) библиотека обрабатывает все события, которые произошли с момента последнего вызова этой функции.
- `glfw.wait_events()` — функция, которая приостанавливает выполнение программы до тех пор, пока не произойдет одно из событий, связанных с окном, таких как нажатие клавиш, движение мыши, изменение размера окна и т.д.
- `glfw.wait_events_timeout(timeout)` - блокирует выполнение программы до тех пор, пока не произойдет событие или не истечет заданный таймаут.
- `glfw.get_time()` — возвращает (float) текущее время в секундах с момента инициализации библиотеки.

## Управление вводом

- `glfw.get_key(window, key)` - Возвращает состояние клавиши (нажата, отпущена и т.д.) для указанного окна.
  - **key**: Код клавиши, например `glfw.KEY_A`.
  - **return**: 
    - `glfw.RELEASE`: Клавиша не нажата.
    - `glfw.PRESS`: Клавиша нажата.
    - `glfw.REPEAT`: Клавиша нажата и удерживается (при этом она будет возвращать `glfw.REPEAT`, если она удерживается после первого нажатия).
- `glfw.get_mouse_button(window, button)` - Возвращает состояние кнопки мыши для указанного окна.
  - **button**: код клавиши, например `glfw.MOUSE_BUTTON_LEFT`
    - `glfw.RELEASE`: Кнопка не нажата.
    - `glfw.PRESS`: Кнопка нажата.
- `glfw.get_cursor_pos(window)` - Возвращает текущую позицию курсора мыши в окне.
  - **return**: (x,y)
- `glfw.set_cursor_pos(window, xpos, ypos)` - Устанавливает позицию курсора мыши в окне.
## Настройка параметров окна
- `glfw.window_hint(hint, value)` - Устанавливает параметры для создания окна, такие как возможность изменения размера, количество буферов и т.д. Эти параметры должны быть установлены перед вызовом `glfw.create_window()`.
  - `glfw.window_hint(glfw.RESIZABLE, glfw.TRUE)` - `glfw.RESIZABLE`: Указывает, может ли окно изменять размер `glfw.TRUE`,`glfw.FALSE`
  - `glfw.window_hint(glfw.VISIBLE, glfw.FALSE)` - `glfw.VISIBLE`: Указывает, будет ли окно видимым при создании. Значение `glfw.FALSE` делает окно невидимым до тех пор, пока вы не сделаете его видимым вручную.
## Работа с мониторами
- `glfw.get_monitors()` - Возвращает список всех доступных мониторов. (список указателей на объекты мониторов.) или None
- `glfw.get_primary_monitor()` - Возвращает основной монитор. (указатель на основной монитор.) или None
## Работа с контекстами
- `glfw.make_context_current(window)` - Устанавливает указанный контекст окна как текущий.
  - **window**: Указатель на окно, для которого вы хотите установить контекст OpenGL.
- `glfw.swap_interval(interval)` - Устанавливает интервал вертикальной синхронизации (V-Sync) для текущего контекста OpenGL.
  - **interval**: 0 - без синхронизации; 1 - синхронизация с частотой обновления экрана; 2 и более - Обмен буферов происходит каждые N кадров, где N — значение интервала.

# OpenGL

- `glClear(GLbitfield mask)` - для очистки указанных буферов, таких как цветовой буфер, буфер глубины и буфер трафарета.
  - **mask (GLbitfield)**: Маска, указывающая, какие буферы должны быть очищены.
    - **GL_COLOR_BUFFER_BIT**: Очищает цветовой буфер.
    - **GL_DEPTH_BUFFER_BIT**: Очищает буфер глубины.
    - **GL_STENCIL_BUFFER_BIT**: Очищает буфер трафарета.
- `glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)` - используется для установки цвета, которым будет очищен цветовой буфер при вызове функции `glClear()`
  - **red**: 0.0 - 1.0
  - **green**: 0.0 - 1.0
  - **blue**: 0.0 - 1.0
  - **alpha**: 0.0 - 1.0
- `glFlush()` - используется для принудительного выполнения всех ранее вызванных команд OpenGL.
## Координаты
- `glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far)`, определяет координатную систему, на которую полагается OpenGL при отрисовке финального изображения и проецировании изображения на экран.Все объекты, находящиеся в пределах указанных границ (left, right, bottom, top) и между ближней и дальней плоскостями (near и far), будут отображаться на экране.
  - **left** - Координата левой границы проекции.
  - **right** - Координата правой границы проекции.
  - **bottom** - Координата нижней границы проекции.
  - **top** - Координата верхней границы проекции.
  - **near** - Координата ближней плоскости отсечения.
  - **far** - Координата дальней плоскости отсечения.

## Окно

- `glViewport(GLint x, GLint y, GLsizei width, GLsizei height)` - определяет область окна, в которую будет выводиться изображение. 
  - **x**: Положение по оси X (в пикселях) в окне, где начинается область просмотра. Значение 0 соответствует левому краю окна.
  - **y**: Положение по оси Y (в пикселях) в окне, где начинается область просмотра. Значение 0 соответствует нижнему краю окна. в OpenGL координаты Y увеличиваются вверх.
  - **width**: Ширина области просмотра в пикселях.
  - **height**: Высота области просмотра в пикселях.

- `glMatrixMode(GLenum mode)` - устанавливает текущую матрицу для последующих операций с матрицами. 
  - **mode**: Указывает, какую матрицу вы хотите установить как текущую. Возможные значения:
    - **GL_MODELVIEW**: Устанавливает модельно-вью матрицу, которая используется для трансформации объектов в сцене и для определения положения камеры.
    - **GL_PROJECTION**: Устанавливает проекционную матрицу, которая определяет, как 3D-сцена проецируется на 2D-экран. Это может быть перспектива или ортографическая проекция.
    - **GL_TEXTURE**: Устанавливает матрицу текстуры, которая используется для трансформации текстурных координат.

- `glLoadIdentity(void)` - сбрасывает текущую матрицу к единичной матрице.Единичная матрица — это матрица, которая не вносит изменений в вектор, когда применяется к нему.



## Работа с матрицей

- `glMatrixMode(GLenum mode)` - устанавливает текущую матрицу для последующих операций с матрицами. 
  - **mode**: Указывает, какую матрицу вы хотите установить как текущую. Возможные значения:
    - **GL_MODELVIEW**: Устанавливает модельно-вью матрицу, которая используется для трансформации объектов в сцене и для определения положения камеры.
    - **GL_PROJECTION**: Устанавливает проекционную матрицу, которая определяет, как 3D-сцена проецируется на 2D-экран. Это может быть перспектива или ортографическая проекция.
    - **GL_TEXTURE**: Устанавливает матрицу текстуры, которая используется для трансформации текстурных координат.

- `void glPushMatrix(void);` - используется для сохранения текущей матрицы трансформации в стек матриц.
- `void glPopMatrix(void);` - используется для восстановления последней сохраненной матрицы из стека матриц. 


## Отрисовка объектов

- `glBegin(GLenum mode)` - это функция в OpenGL, которая используется для начала определения примитивов, таких как точки, линии и полигоны. 
  - **mode**
    - **GL_POINTS**: Рисует точки.
    - **GL_LINES**: Рисует линии между парами вершин.
    - **GL_LINE_LOOP**: Рисует замкнутый контур линий.
    - **GL_LINE_STRIP**: Рисует последовательность соединенных линий.
    - **GL_TRIANGLES**: Рисует треугольники, где каждые три вершины образуют один треугольник.
    - **GL_TRIANGLE_STRIP**: Рисует последовательность треугольников, где каждая новая вершина добавляет новый треугольник.
    - **GL_TRIANGLE_FAN**: Рисует треугольники, исходящие из одной центральной вершины.
    - **GL_QUADS**: Рисует четырехугольники, где каждые четыре вершины образуют один четырехугольник.
    - **GL_QUAD_STRIP**: Рисует последовательность четырехугольников.
    - **GL_POLYGON** - позволяет рисовать многоугольники, состоящие из произвольного количества вершин. (> 3 вершин)

> Параметры для задания геометрических примитивов
![Изображение не найдено](resources\primitive-params.png)

- `glColor*` -  используется для установки цвета текущего рисуемого объекта.
  - **`void glColor3f(GLfloat red, GLfloat green, GLfloat blue);`**
  - **`void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);`**
  - **`void glColor3d(GLdouble red, GLdouble green, GLdouble blue);`**
  - **`void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);`**
  - **`void glColor3ub(GLubyte red, GLubyte green, GLubyte blue);`**
  - **`void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);`**

- `glVertex*()` — это набор функций в OpenGL, используемых для определения вершин в процессе рендеринга.
  - **`glVertex2f(GLfloat x, GLfloat y)`**: Определяет 2D-вершину с плавающей точкой.
  - **`glVertex2i(GLint x, GLint y)`**: Определяет 2D-вершину с целыми числами.
  - **`glVertex3f(GLfloat x, GLfloat y, GLfloat z)`**: Определяет 3D-вершину с плавающей точкой.
  - **`glVertex3i(GLint x, GLint y, GLint z)`**: Определяет 3D-вершину с целыми числами.
  - **`glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)`**: Определяет 4D-вершину с плавающей точкой (используется для гомогенных координат).

- `glTexCoord*()` — это набор функций в OpenGL, используемых для задания текстурных координат вершин.
  - **`glTexCoord1f(GLfloat s)`**: Задает текстурную координату в 1D (одномерную).
  - **`glTexCoord2f(GLfloat s, GLfloat t)`**: Задает текстурные координаты в 2D (двумерные).
  - **`glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)`**: Задает текстурные координаты в 3D (трехмерные).
  - **`glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)`**: Задает текстурные координаты в 4D (четырехмерные). 

- `glNormal*()` — это набор функций в OpenGL, используемых для задания нормалей вершин. 
  - **`glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)`**: Задает нормаль в 3D-пространстве с плавающей точкой.
  - **`glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)`**: Задает нормаль в 3D-пространстве с двойной точностью.
  - **`glNormal3i(GLint nx, GLint ny, GLint nz)`**: Задает нормаль в 3D-пространстве с целыми числами.

- `glRect*` -  набор функций которые используются для рисования прямоугольников.
  - **`void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);`** - Рисует прямоугольник, используя координаты с плавающей запятой 
  - **`void glRecti(GLint x1, GLint y1, GLint x2, GLint y2);`** - Рисует прямоугольник, используя целочисленные координаты 
  - **`void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);`** - Рисует прямоугольник, используя двойные координаты
  - **параметры:**
    - **x1, x2** - Координаты нижнего левого угла прямоугольника.
    - **y1, y2** - Координаты верхнего правого угла прямоугольника.

- `void glFrontFace(GLenum mode);` - определяет, какая сторона примитивов (например, треугольников) считается "лицевой" (front face) "обратной" (back face). Это важно для управления отрисовкой и оптимизации рендеринга
  - **mode:**
  Определяет, какая сторона считается лицевой. Возможные значения:
    - **GL_CCW**: Примитивы, определенные против часовой стрелки, считаются лицевыми. Это значение по умолчанию.
    - **GL_CW**: Примитивы, определенные по часовой стрелке, считаются лицевыми.

- `void glPolygonMode(GLenum face, GLenum mode);` - правляет тем, как отрисовываются полигоны (например, треугольники, квадраты и другие многоугольники). Она позволяет задавать режим отображения для лицевых и обратных сторон полигонов
  - **face:**
    - **GL_FRONT**: Лицевая сторона полигона.
    - **GL_BACK**: Обратная сторона полигона.
    - **GL_FRONT_AND_BACK**: Оба типа сторон.

    - **mode:**
    - **GL_POINT**: Отображение полигонов в виде точек.
    - **GL_LINE**: Отображение полигонов в виде линий (контуров).
    - **GL_FILL**: Отображение полигонов в виде заполненных фигур (это значение по умолчанию).

- `void glCullFace(GLenum mode);` - управляет отсечением (culling) полигонов, позволяя игнорировать (не отрисовывать) определенные стороны примитивов.
  - **mode:**
    - **GL_FRONT**: Отсечение лицевых сторон полигонов.
    - **GL_BACK**: Отсечение обратных сторон полигонов.
    - **GL_FRONT_AND_BACK**: Отсечение как лицевых, так и обратных сторон полигонов.

- `void glPointSize(GLfloat size);` - устанавливает размер точек
  - **size:** - Размер точки в пикселях. Значение должно быть больше нуля. 

- `void glLineWidth(GLfloat width);` - устанавливает ширину линий
  - **width:** -  Ширина линии в пикселях.

- `void glLineStipple(GLint factor, GLushort pattern);` - которая позволяет задавать стиль (шаблон) рисования линий
  - **factor:** Умножитель для шаблона. Этот параметр определяет, как часто повторяется шаблон. Например, если factor равен 1, то шаблон будет применяться без изменений. Если factor равен 2, то каждый бит шаблона будет повторяться дважды.
  - **pattern:** 
    - **Сплошная линия:** Шаблон: 0xFFFF
    - **Пунктирная линия:** Шаблон: 0xAAAA
    - **Штриховая линия:** Шаблон: 0xF0F0
    - **Двойной пунктир:** Шаблон: 0xCCCC
    - **Штрих с одним пропуском:** Шаблон: 0xFF00
    - **Пунктир с одним пропуском** Шаблон: 0xF0F0
    - **Штрих с переменной длиной** Шаблон: 0xC3C3
    - **Пунктир с переменной длиной:** Шаблон: 0xA0A0

- `void glShadeModel(GLenum mode);` - устанавливает модель затенения для последующей отрисовки объектов.
  - **mode:**
    - **GL_FLAT:** Плоское затенение.
    - **GL_SMOOTH:** Гладкое затенение.

- `void glPolygonStipple(const GLubyte *mask);` - позволяет задавать шаблон (паттерн) для заполнения многоугольников.
  - **mask:** Указатель на массив из 32 байтов (256 бит), который определяет шаблон заполнения. Каждый бит в этом массиве указывает, будет ли соответствующий пиксель закрашен (1) или пропущен (0).
    - пример:
    ```
    GLubyte stipplePattern[32] = {
      0xFF, 0x81, 0x81, 0xFF, // Пример паттерна
      0xFF, 0x81, 0x81, 0xFF,
      0xFF, 0x81, 0x81, 0xFF,
      0xFF, 0x81, 0x81, 0xFF
  };
    ```



- `glEnd(void)` — это функция в OpenGL, которая используется для завершения определения примитивов, начатого с помощью функции `glBegin()`

## Машина состояния, state machine

- `glEnable(GLenum cap)` - используется для включения различных возможностей рендеринга. 
  - **cap**
    - **GL_DEPTH_TEST**: Включает тест глубины.
    - **GL_BLEND**: Включает смешивание (блендинг).
    - **GL_CULL_FACE**: Включает отсечение (culling) лиц.
    - **GL_LIGHTING**: Включает освещение.

- `glGetBooleanv(GLenum pname, GLboolean *data)` - используется для получения значения параметров состояния, хранящихся в виде логических значений (true/false). 
  - **name:** 
  - **GL_DEPTH_TEST:** возвращает, включен ли тест глубины.
  - **GL_CULL_FACE:** возвращает, включен ли отсечение.
  - **GL_BLEND:** возвращает, включено ли смешивание.

- `glDisable(GLenum cap)` - используется для отключения определенных возможностей рендеринга. 
  - **cap:**
  - **GL_DEPTH_TEST:** отключает тест глубины.
  - **GL_CULL_FACE:** отключает отсечение (culling) полигонов.
  - **GL_BLEND:** отключает смешивание (blending) цветов.
  - **GL_LIGHTING:** отключает освещение.
  - **GL_TEXTURE_2D:** отключает 2D текстурирование.

## Работа с 3д объектами

- `void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);` - используется для применения вращения к текущей матрице трансформации. Это позволяет вращать объекты вокруг заданной оси на определенный угол.
  - **angle:** - Угол вращения в градусах. Положительные значения вращают объект против часовой стрелки, а отрицательные — по часовой стрелке.
  - **x, y, z :** - Координаты вектора, определяющего ось вращения. Этот вектор должен быть нормализован (т.е. его длина должна быть равна 1) для корректного вращения.
  - **пример:**
    - **`glRotatef(45.0f, 0.0f, 1.0f, 0.0f);`** - Вращение объекта на 45 градусов вокруг оси Y



## Работа с буфером

- `void glutInit(int *argc, char **argv);` - используется для инициализации библиотеки GLUT и подготовки к созданию окна для рендеринга с использованием OpenGL.
  - **argc:** - Указатель на количество аргументов командной строки. Обычно передается `&argc` из функции `main`.
  - **argv:** - Указатель на массив строк, представляющий аргументы командной строки. Обычно передается `argv` из функции `main`.

- `void glutSwapBuffers(void);`  - используется для обмена буферов в контексте двойной буферизации. Двойная буферизация — это техника, которая помогает избежать мерцания и обеспечивает более плавное отображение графики, особенно при анимации.


## Работа с текстом

- `void glutBitmapCharacter(void *font, int character);` - используется для отображения символов в битмапном шрифте на экране. 
  - **font:** Указатель на шрифт, который будет использоваться для отображения текста.
    - `GLUT_BITMAP8_BY_13`
    - `GLUT_BITMAP9_BY_15`
    - `GLUT_BITMAP_TIMES_ROMAN_10`
    - `GLUT_BITMAP_TIMES_ROMAN_24`
    - `GLUT_BITMAP_HELVETICA_10`
    - `GLUT_BITMAP_HELVETICA_12`
    - `GLUT_BITMAP_HELVETICA_18`
  - **character**: Символ, который вы хотите отобразить. Это значение должно быть целым числом, представляющим ASCII-код символа.
